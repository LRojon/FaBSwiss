{"ast":null,"code":"import { createMatch, MATCH_RESULT } from '../models/types.js';\n\n/**\r\n * Service pour gérer les pairings de tournois suisses\r\n */\nexport class PairingService {\n  /**\r\n   * Génère les pairings pour un round suisse\r\n   * @param {Array} players - Liste des joueurs actifs\r\n   * @param {Array} previousMatches - Matches des rounds précédents\r\n   * @param {number} roundNumber - Numéro du round à générer\r\n   * @returns {Array} Liste des matches pour ce round\r\n   */\n  static generateSwissPairings(players, previousMatches, roundNumber) {\n    if (players.length < 2) {\n      throw new Error('Au moins 2 joueurs sont nécessaires pour créer des pairings');\n    }\n\n    // Calculer les standings actuels\n    const standings = this.calculateStandings(players, previousMatches);\n\n    // Grouper par points\n    const pointGroups = this.groupByPoints(standings);\n\n    // Générer les pairings en évitant les rematches\n    const pairings = [];\n    const pairedPlayers = new Set();\n\n    // Pour chaque groupe de points (du plus haut au plus bas)\n    const sortedPointGroups = Object.keys(pointGroups).map(Number).sort((a, b) => b - a);\n    for (const points of sortedPointGroups) {\n      const group = pointGroups[points].filter(player => !pairedPlayers.has(player.id));\n      if (group.length === 0) continue;\n\n      // Si un nombre impair de joueurs dans le groupe, essayer de pair down\n      if (group.length % 2 === 1) {\n        const pairDownPlayer = group.pop();\n\n        // Essayer de trouver un joueur dans un groupe de points inférieur\n        const lowerPointsPlayer = this.findPairDownOpponent(pairDownPlayer, pointGroups, points, pairedPlayers, previousMatches);\n        if (lowerPointsPlayer) {\n          pairings.push(createMatch(pairDownPlayer.id, lowerPointsPlayer.id, roundNumber));\n          pairedPlayers.add(pairDownPlayer.id);\n          pairedPlayers.add(lowerPointsPlayer.id);\n        } else {\n          // Remettre le joueur dans le groupe si pas de pair down possible\n          group.push(pairDownPlayer);\n        }\n      }\n\n      // Pairer les joueurs restants dans le groupe\n      const groupPairings = this.pairPlayersInGroup(group, previousMatches, roundNumber);\n      pairings.push(...groupPairings);\n      groupPairings.forEach(match => {\n        pairedPlayers.add(match.player1Id);\n        pairedPlayers.add(match.player2Id);\n      });\n    }\n\n    // Gérer les joueurs restants (bye ou problèmes de pairing)\n    const unpairedPlayers = players.filter(player => !pairedPlayers.has(player.id));\n    if (unpairedPlayers.length === 1) {\n      // Donner un bye au joueur restant\n      pairings.push(this.createByeMatch(unpairedPlayers[0], roundNumber));\n    } else if (unpairedPlayers.length > 1) {\n      // Forcer des pairings même s'ils ne sont pas optimaux\n      const forcedPairings = this.forcePairings(unpairedPlayers, roundNumber);\n      pairings.push(...forcedPairings);\n    }\n    return pairings;\n  }\n\n  /**\r\n   * Calcule les standings actuels des joueurs\r\n   */\n  static calculateStandings(players, matches) {\n    const standings = players.map(player => ({\n      ...player,\n      points: 0,\n      wins: 0,\n      losses: 0,\n      draws: 0,\n      opponents: []\n    }));\n    const playerMap = new Map(standings.map(p => [p.id, p]));\n\n    // Calculer les statistiques basées sur les matches\n    matches.forEach(match => {\n      if (match.result === MATCH_RESULT.PENDING) return;\n      const player1 = playerMap.get(match.player1Id);\n      const player2 = playerMap.get(match.player2Id);\n      if (!player1 || !player2) return;\n\n      // Ajouter l'adversaire à la liste\n      player1.opponents.push(match.player2Id);\n      player2.opponents.push(match.player1Id);\n\n      // Calculer les points\n      if (match.result === MATCH_RESULT.PLAYER1_WIN) {\n        player1.wins++;\n        player1.points += 3;\n        player2.losses++;\n      } else if (match.result === MATCH_RESULT.PLAYER2_WIN) {\n        player2.wins++;\n        player2.points += 3;\n        player1.losses++;\n      } else if (match.result === MATCH_RESULT.DRAW) {\n        player1.draws++;\n        player1.points += 1;\n        player2.draws++;\n        player2.points += 1;\n      }\n    });\n    return standings.sort((a, b) => b.points - a.points || b.wins - a.wins);\n  }\n\n  /**\r\n   * Groupe les joueurs par points\r\n   */\n  static groupByPoints(standings) {\n    const groups = {};\n    standings.forEach(player => {\n      if (!groups[player.points]) {\n        groups[player.points] = [];\n      }\n      groups[player.points].push(player);\n    });\n    return groups;\n  }\n\n  /**\r\n   * Trouve un adversaire pour un pair down\r\n   */\n  static findPairDownOpponent(player, pointGroups, currentPoints, pairedPlayers, previousMatches) {\n    const sortedPoints = Object.keys(pointGroups).map(Number).filter(p => p < currentPoints).sort((a, b) => b - a);\n    for (const points of sortedPoints) {\n      const candidates = pointGroups[points].filter(candidate => !pairedPlayers.has(candidate.id) && !this.havePlayedBefore(player, candidate, previousMatches));\n      if (candidates.length > 0) {\n        // Retirer le joueur du groupe\n        const opponent = candidates[0];\n        const index = pointGroups[points].indexOf(opponent);\n        pointGroups[points].splice(index, 1);\n        return opponent;\n      }\n    }\n    return null;\n  }\n\n  /**\r\n   * Vérifie si deux joueurs ont déjà joué l'un contre l'autre\r\n   */\n  static havePlayedBefore(player1, player2, previousMatches) {\n    return previousMatches.some(match => match.player1Id === player1.id && match.player2Id === player2.id || match.player1Id === player2.id && match.player2Id === player1.id);\n  }\n\n  /**\r\n   * Pairie les joueurs dans un groupe de points\r\n   */\n  static pairPlayersInGroup(players, previousMatches, roundNumber) {\n    const pairings = [];\n    const remaining = [...players];\n    while (remaining.length >= 2) {\n      const player1 = remaining.shift();\n\n      // Trouver le meilleur adversaire pour player1\n      let bestOpponentIndex = -1;\n      for (let i = 0; i < remaining.length; i++) {\n        if (!this.havePlayedBefore(player1, remaining[i], previousMatches)) {\n          bestOpponentIndex = i;\n          break;\n        }\n      }\n\n      // Si aucun adversaire non rencontré, prendre le premier disponible\n      if (bestOpponentIndex === -1 && remaining.length > 0) {\n        bestOpponentIndex = 0;\n      }\n      if (bestOpponentIndex >= 0) {\n        const player2 = remaining.splice(bestOpponentIndex, 1)[0];\n        pairings.push(createMatch(player1.id, player2.id, roundNumber));\n      }\n    }\n    return pairings;\n  }\n\n  /**\r\n   * Crée un match bye pour un joueur\r\n   */\n  static createByeMatch(player, roundNumber) {\n    return {\n      ...createMatch(player.id, null, roundNumber),\n      result: MATCH_RESULT.PLAYER1_WIN,\n      isBye: true\n    };\n  }\n\n  /**\r\n   * Force des pairings pour les joueurs restants\r\n   */\n  static forcePairings(players, roundNumber) {\n    const pairings = [];\n    const remaining = [...players];\n    while (remaining.length >= 2) {\n      const player1 = remaining.pop();\n      const player2 = remaining.pop();\n      pairings.push(createMatch(player1.id, player2.id, roundNumber));\n    }\n\n    // S'il reste un joueur, lui donner un bye\n    if (remaining.length === 1) {\n      pairings.push(this.createByeMatch(remaining[0], roundNumber));\n    }\n    return pairings;\n  }\n\n  /**\r\n   * Valide si un pairing manuel est acceptable\r\n   */\n  static validateManualPairing(player1Id, player2Id, previousMatches) {\n    if (player1Id === player2Id) {\n      return {\n        valid: false,\n        reason: 'Un joueur ne peut pas jouer contre lui-même'\n      };\n    }\n    const hasPlayed = previousMatches.some(match => match.player1Id === player1Id && match.player2Id === player2Id || match.player1Id === player2Id && match.player2Id === player1Id);\n    if (hasPlayed) {\n      return {\n        valid: false,\n        reason: 'Ces joueurs ont déjà joué l\\'un contre l\\'autre'\n      };\n    }\n    return {\n      valid: true\n    };\n  }\n\n  /**\r\n   * Modifie un pairing existant\r\n   */\n  static modifyPairing(matches, oldMatchId, newPlayer1Id, newPlayer2Id) {\n    const matchIndex = matches.findIndex(m => m.id === oldMatchId);\n    if (matchIndex === -1) {\n      throw new Error('Match introuvable');\n    }\n    const oldMatch = matches[matchIndex];\n\n    // Créer le nouveau match\n    const newMatch = {\n      ...oldMatch,\n      player1Id: newPlayer1Id,\n      player2Id: newPlayer2Id,\n      result: MATCH_RESULT.PENDING,\n      player1Games: 0,\n      player2Games: 0\n    };\n\n    // Remplacer le match\n    matches[matchIndex] = newMatch;\n    return matches;\n  }\n}","map":{"version":3,"names":["createMatch","MATCH_RESULT","PairingService","generateSwissPairings","players","previousMatches","roundNumber","length","Error","standings","calculateStandings","pointGroups","groupByPoints","pairings","pairedPlayers","Set","sortedPointGroups","Object","keys","map","Number","sort","a","b","points","group","filter","player","has","id","pairDownPlayer","pop","lowerPointsPlayer","findPairDownOpponent","push","add","groupPairings","pairPlayersInGroup","forEach","match","player1Id","player2Id","unpairedPlayers","createByeMatch","forcedPairings","forcePairings","matches","wins","losses","draws","opponents","playerMap","Map","p","result","PENDING","player1","get","player2","PLAYER1_WIN","PLAYER2_WIN","DRAW","groups","currentPoints","sortedPoints","candidates","candidate","havePlayedBefore","opponent","index","indexOf","splice","some","remaining","shift","bestOpponentIndex","i","isBye","validateManualPairing","valid","reason","hasPlayed","modifyPairing","oldMatchId","newPlayer1Id","newPlayer2Id","matchIndex","findIndex","m","oldMatch","newMatch","player1Games","player2Games"],"sources":["D:/Projet/FaBSwiss/src/services/pairing.js"],"sourcesContent":["import { createMatch, MATCH_RESULT } from '../models/types.js';\r\n\r\n/**\r\n * Service pour gérer les pairings de tournois suisses\r\n */\r\nexport class PairingService {\r\n  \r\n  /**\r\n   * Génère les pairings pour un round suisse\r\n   * @param {Array} players - Liste des joueurs actifs\r\n   * @param {Array} previousMatches - Matches des rounds précédents\r\n   * @param {number} roundNumber - Numéro du round à générer\r\n   * @returns {Array} Liste des matches pour ce round\r\n   */\r\n  static generateSwissPairings(players, previousMatches, roundNumber) {\r\n    if (players.length < 2) {\r\n      throw new Error('Au moins 2 joueurs sont nécessaires pour créer des pairings');\r\n    }\r\n\r\n    // Calculer les standings actuels\r\n    const standings = this.calculateStandings(players, previousMatches);\r\n    \r\n    // Grouper par points\r\n    const pointGroups = this.groupByPoints(standings);\r\n    \r\n    // Générer les pairings en évitant les rematches\r\n    const pairings = [];\r\n    const pairedPlayers = new Set();\r\n    \r\n    // Pour chaque groupe de points (du plus haut au plus bas)\r\n    const sortedPointGroups = Object.keys(pointGroups)\r\n      .map(Number)\r\n      .sort((a, b) => b - a);\r\n\r\n    for (const points of sortedPointGroups) {\r\n      const group = pointGroups[points].filter(player => !pairedPlayers.has(player.id));\r\n      \r\n      if (group.length === 0) continue;\r\n      \r\n      // Si un nombre impair de joueurs dans le groupe, essayer de pair down\r\n      if (group.length % 2 === 1) {\r\n        const pairDownPlayer = group.pop();\r\n        \r\n        // Essayer de trouver un joueur dans un groupe de points inférieur\r\n        const lowerPointsPlayer = this.findPairDownOpponent(\r\n          pairDownPlayer, \r\n          pointGroups, \r\n          points, \r\n          pairedPlayers, \r\n          previousMatches\r\n        );\r\n        \r\n        if (lowerPointsPlayer) {\r\n          pairings.push(createMatch(pairDownPlayer.id, lowerPointsPlayer.id, roundNumber));\r\n          pairedPlayers.add(pairDownPlayer.id);\r\n          pairedPlayers.add(lowerPointsPlayer.id);\r\n        } else {\r\n          // Remettre le joueur dans le groupe si pas de pair down possible\r\n          group.push(pairDownPlayer);\r\n        }\r\n      }\r\n      \r\n      // Pairer les joueurs restants dans le groupe\r\n      const groupPairings = this.pairPlayersInGroup(group, previousMatches, roundNumber);\r\n      pairings.push(...groupPairings);\r\n      \r\n      groupPairings.forEach(match => {\r\n        pairedPlayers.add(match.player1Id);\r\n        pairedPlayers.add(match.player2Id);\r\n      });\r\n    }\r\n    \r\n    // Gérer les joueurs restants (bye ou problèmes de pairing)\r\n    const unpairedPlayers = players.filter(player => !pairedPlayers.has(player.id));\r\n    if (unpairedPlayers.length === 1) {\r\n      // Donner un bye au joueur restant\r\n      pairings.push(this.createByeMatch(unpairedPlayers[0], roundNumber));\r\n    } else if (unpairedPlayers.length > 1) {\r\n      // Forcer des pairings même s'ils ne sont pas optimaux\r\n      const forcedPairings = this.forcePairings(unpairedPlayers, roundNumber);\r\n      pairings.push(...forcedPairings);\r\n    }\r\n    \r\n    return pairings;\r\n  }\r\n\r\n  /**\r\n   * Calcule les standings actuels des joueurs\r\n   */\r\n  static calculateStandings(players, matches) {\r\n    const standings = players.map(player => ({\r\n      ...player,\r\n      points: 0,\r\n      wins: 0,\r\n      losses: 0,\r\n      draws: 0,\r\n      opponents: []\r\n    }));\r\n\r\n    const playerMap = new Map(standings.map(p => [p.id, p]));\r\n\r\n    // Calculer les statistiques basées sur les matches\r\n    matches.forEach(match => {\r\n      if (match.result === MATCH_RESULT.PENDING) return;\r\n\r\n      const player1 = playerMap.get(match.player1Id);\r\n      const player2 = playerMap.get(match.player2Id);\r\n\r\n      if (!player1 || !player2) return;\r\n\r\n      // Ajouter l'adversaire à la liste\r\n      player1.opponents.push(match.player2Id);\r\n      player2.opponents.push(match.player1Id);\r\n\r\n      // Calculer les points\r\n      if (match.result === MATCH_RESULT.PLAYER1_WIN) {\r\n        player1.wins++;\r\n        player1.points += 3;\r\n        player2.losses++;\r\n      } else if (match.result === MATCH_RESULT.PLAYER2_WIN) {\r\n        player2.wins++;\r\n        player2.points += 3;\r\n        player1.losses++;\r\n      } else if (match.result === MATCH_RESULT.DRAW) {\r\n        player1.draws++;\r\n        player1.points += 1;\r\n        player2.draws++;\r\n        player2.points += 1;\r\n      }\r\n    });\r\n\r\n    return standings.sort((a, b) => b.points - a.points || b.wins - a.wins);\r\n  }\r\n\r\n  /**\r\n   * Groupe les joueurs par points\r\n   */\r\n  static groupByPoints(standings) {\r\n    const groups = {};\r\n    standings.forEach(player => {\r\n      if (!groups[player.points]) {\r\n        groups[player.points] = [];\r\n      }\r\n      groups[player.points].push(player);\r\n    });\r\n    return groups;\r\n  }\r\n\r\n  /**\r\n   * Trouve un adversaire pour un pair down\r\n   */\r\n  static findPairDownOpponent(player, pointGroups, currentPoints, pairedPlayers, previousMatches) {\r\n    const sortedPoints = Object.keys(pointGroups)\r\n      .map(Number)\r\n      .filter(p => p < currentPoints)\r\n      .sort((a, b) => b - a);\r\n\r\n    for (const points of sortedPoints) {\r\n      const candidates = pointGroups[points].filter(candidate => \r\n        !pairedPlayers.has(candidate.id) && \r\n        !this.havePlayedBefore(player, candidate, previousMatches)\r\n      );\r\n\r\n      if (candidates.length > 0) {\r\n        // Retirer le joueur du groupe\r\n        const opponent = candidates[0];\r\n        const index = pointGroups[points].indexOf(opponent);\r\n        pointGroups[points].splice(index, 1);\r\n        return opponent;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Vérifie si deux joueurs ont déjà joué l'un contre l'autre\r\n   */\r\n  static havePlayedBefore(player1, player2, previousMatches) {\r\n    return previousMatches.some(match => \r\n      (match.player1Id === player1.id && match.player2Id === player2.id) ||\r\n      (match.player1Id === player2.id && match.player2Id === player1.id)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Pairie les joueurs dans un groupe de points\r\n   */\r\n  static pairPlayersInGroup(players, previousMatches, roundNumber) {\r\n    const pairings = [];\r\n    const remaining = [...players];\r\n\r\n    while (remaining.length >= 2) {\r\n      const player1 = remaining.shift();\r\n      \r\n      // Trouver le meilleur adversaire pour player1\r\n      let bestOpponentIndex = -1;\r\n      for (let i = 0; i < remaining.length; i++) {\r\n        if (!this.havePlayedBefore(player1, remaining[i], previousMatches)) {\r\n          bestOpponentIndex = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Si aucun adversaire non rencontré, prendre le premier disponible\r\n      if (bestOpponentIndex === -1 && remaining.length > 0) {\r\n        bestOpponentIndex = 0;\r\n      }\r\n\r\n      if (bestOpponentIndex >= 0) {\r\n        const player2 = remaining.splice(bestOpponentIndex, 1)[0];\r\n        pairings.push(createMatch(player1.id, player2.id, roundNumber));\r\n      }\r\n    }\r\n\r\n    return pairings;\r\n  }\r\n\r\n  /**\r\n   * Crée un match bye pour un joueur\r\n   */\r\n  static createByeMatch(player, roundNumber) {\r\n    return {\r\n      ...createMatch(player.id, null, roundNumber),\r\n      result: MATCH_RESULT.PLAYER1_WIN,\r\n      isBye: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Force des pairings pour les joueurs restants\r\n   */\r\n  static forcePairings(players, roundNumber) {\r\n    const pairings = [];\r\n    const remaining = [...players];\r\n\r\n    while (remaining.length >= 2) {\r\n      const player1 = remaining.pop();\r\n      const player2 = remaining.pop();\r\n      pairings.push(createMatch(player1.id, player2.id, roundNumber));\r\n    }\r\n\r\n    // S'il reste un joueur, lui donner un bye\r\n    if (remaining.length === 1) {\r\n      pairings.push(this.createByeMatch(remaining[0], roundNumber));\r\n    }\r\n\r\n    return pairings;\r\n  }\r\n\r\n  /**\r\n   * Valide si un pairing manuel est acceptable\r\n   */\r\n  static validateManualPairing(player1Id, player2Id, previousMatches) {\r\n    if (player1Id === player2Id) {\r\n      return { valid: false, reason: 'Un joueur ne peut pas jouer contre lui-même' };\r\n    }\r\n\r\n    const hasPlayed = previousMatches.some(match => \r\n      (match.player1Id === player1Id && match.player2Id === player2Id) ||\r\n      (match.player1Id === player2Id && match.player2Id === player1Id)\r\n    );\r\n\r\n    if (hasPlayed) {\r\n      return { valid: false, reason: 'Ces joueurs ont déjà joué l\\'un contre l\\'autre' };\r\n    }\r\n\r\n    return { valid: true };\r\n  }\r\n\r\n  /**\r\n   * Modifie un pairing existant\r\n   */\r\n  static modifyPairing(matches, oldMatchId, newPlayer1Id, newPlayer2Id) {\r\n    const matchIndex = matches.findIndex(m => m.id === oldMatchId);\r\n    if (matchIndex === -1) {\r\n      throw new Error('Match introuvable');\r\n    }\r\n\r\n    const oldMatch = matches[matchIndex];\r\n    \r\n    // Créer le nouveau match\r\n    const newMatch = {\r\n      ...oldMatch,\r\n      player1Id: newPlayer1Id,\r\n      player2Id: newPlayer2Id,\r\n      result: MATCH_RESULT.PENDING,\r\n      player1Games: 0,\r\n      player2Games: 0\r\n    };\r\n\r\n    // Remplacer le match\r\n    matches[matchIndex] = newMatch;\r\n    \r\n    return matches;\r\n  }\r\n}"],"mappings":"AAAA,SAASA,WAAW,EAAEC,YAAY,QAAQ,oBAAoB;;AAE9D;AACA;AACA;AACA,OAAO,MAAMC,cAAc,CAAC;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,qBAAqBA,CAACC,OAAO,EAAEC,eAAe,EAAEC,WAAW,EAAE;IAClE,IAAIF,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,6DAA6D,CAAC;IAChF;;IAEA;IACA,MAAMC,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAACN,OAAO,EAAEC,eAAe,CAAC;;IAEnE;IACA,MAAMM,WAAW,GAAG,IAAI,CAACC,aAAa,CAACH,SAAS,CAAC;;IAEjD;IACA,MAAMI,QAAQ,GAAG,EAAE;IACnB,MAAMC,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;;IAE/B;IACA,MAAMC,iBAAiB,GAAGC,MAAM,CAACC,IAAI,CAACP,WAAW,CAAC,CAC/CQ,GAAG,CAACC,MAAM,CAAC,CACXC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC;IAExB,KAAK,MAAME,MAAM,IAAIR,iBAAiB,EAAE;MACtC,MAAMS,KAAK,GAAGd,WAAW,CAACa,MAAM,CAAC,CAACE,MAAM,CAACC,MAAM,IAAI,CAACb,aAAa,CAACc,GAAG,CAACD,MAAM,CAACE,EAAE,CAAC,CAAC;MAEjF,IAAIJ,KAAK,CAAClB,MAAM,KAAK,CAAC,EAAE;;MAExB;MACA,IAAIkB,KAAK,CAAClB,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;QAC1B,MAAMuB,cAAc,GAAGL,KAAK,CAACM,GAAG,CAAC,CAAC;;QAElC;QACA,MAAMC,iBAAiB,GAAG,IAAI,CAACC,oBAAoB,CACjDH,cAAc,EACdnB,WAAW,EACXa,MAAM,EACNV,aAAa,EACbT,eACF,CAAC;QAED,IAAI2B,iBAAiB,EAAE;UACrBnB,QAAQ,CAACqB,IAAI,CAAClC,WAAW,CAAC8B,cAAc,CAACD,EAAE,EAAEG,iBAAiB,CAACH,EAAE,EAAEvB,WAAW,CAAC,CAAC;UAChFQ,aAAa,CAACqB,GAAG,CAACL,cAAc,CAACD,EAAE,CAAC;UACpCf,aAAa,CAACqB,GAAG,CAACH,iBAAiB,CAACH,EAAE,CAAC;QACzC,CAAC,MAAM;UACL;UACAJ,KAAK,CAACS,IAAI,CAACJ,cAAc,CAAC;QAC5B;MACF;;MAEA;MACA,MAAMM,aAAa,GAAG,IAAI,CAACC,kBAAkB,CAACZ,KAAK,EAAEpB,eAAe,EAAEC,WAAW,CAAC;MAClFO,QAAQ,CAACqB,IAAI,CAAC,GAAGE,aAAa,CAAC;MAE/BA,aAAa,CAACE,OAAO,CAACC,KAAK,IAAI;QAC7BzB,aAAa,CAACqB,GAAG,CAACI,KAAK,CAACC,SAAS,CAAC;QAClC1B,aAAa,CAACqB,GAAG,CAACI,KAAK,CAACE,SAAS,CAAC;MACpC,CAAC,CAAC;IACJ;;IAEA;IACA,MAAMC,eAAe,GAAGtC,OAAO,CAACsB,MAAM,CAACC,MAAM,IAAI,CAACb,aAAa,CAACc,GAAG,CAACD,MAAM,CAACE,EAAE,CAAC,CAAC;IAC/E,IAAIa,eAAe,CAACnC,MAAM,KAAK,CAAC,EAAE;MAChC;MACAM,QAAQ,CAACqB,IAAI,CAAC,IAAI,CAACS,cAAc,CAACD,eAAe,CAAC,CAAC,CAAC,EAAEpC,WAAW,CAAC,CAAC;IACrE,CAAC,MAAM,IAAIoC,eAAe,CAACnC,MAAM,GAAG,CAAC,EAAE;MACrC;MACA,MAAMqC,cAAc,GAAG,IAAI,CAACC,aAAa,CAACH,eAAe,EAAEpC,WAAW,CAAC;MACvEO,QAAQ,CAACqB,IAAI,CAAC,GAAGU,cAAc,CAAC;IAClC;IAEA,OAAO/B,QAAQ;EACjB;;EAEA;AACF;AACA;EACE,OAAOH,kBAAkBA,CAACN,OAAO,EAAE0C,OAAO,EAAE;IAC1C,MAAMrC,SAAS,GAAGL,OAAO,CAACe,GAAG,CAACQ,MAAM,KAAK;MACvC,GAAGA,MAAM;MACTH,MAAM,EAAE,CAAC;MACTuB,IAAI,EAAE,CAAC;MACPC,MAAM,EAAE,CAAC;MACTC,KAAK,EAAE,CAAC;MACRC,SAAS,EAAE;IACb,CAAC,CAAC,CAAC;IAEH,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAAC3C,SAAS,CAACU,GAAG,CAACkC,CAAC,IAAI,CAACA,CAAC,CAACxB,EAAE,EAAEwB,CAAC,CAAC,CAAC,CAAC;;IAExD;IACAP,OAAO,CAACR,OAAO,CAACC,KAAK,IAAI;MACvB,IAAIA,KAAK,CAACe,MAAM,KAAKrD,YAAY,CAACsD,OAAO,EAAE;MAE3C,MAAMC,OAAO,GAAGL,SAAS,CAACM,GAAG,CAAClB,KAAK,CAACC,SAAS,CAAC;MAC9C,MAAMkB,OAAO,GAAGP,SAAS,CAACM,GAAG,CAAClB,KAAK,CAACE,SAAS,CAAC;MAE9C,IAAI,CAACe,OAAO,IAAI,CAACE,OAAO,EAAE;;MAE1B;MACAF,OAAO,CAACN,SAAS,CAAChB,IAAI,CAACK,KAAK,CAACE,SAAS,CAAC;MACvCiB,OAAO,CAACR,SAAS,CAAChB,IAAI,CAACK,KAAK,CAACC,SAAS,CAAC;;MAEvC;MACA,IAAID,KAAK,CAACe,MAAM,KAAKrD,YAAY,CAAC0D,WAAW,EAAE;QAC7CH,OAAO,CAACT,IAAI,EAAE;QACdS,OAAO,CAAChC,MAAM,IAAI,CAAC;QACnBkC,OAAO,CAACV,MAAM,EAAE;MAClB,CAAC,MAAM,IAAIT,KAAK,CAACe,MAAM,KAAKrD,YAAY,CAAC2D,WAAW,EAAE;QACpDF,OAAO,CAACX,IAAI,EAAE;QACdW,OAAO,CAAClC,MAAM,IAAI,CAAC;QACnBgC,OAAO,CAACR,MAAM,EAAE;MAClB,CAAC,MAAM,IAAIT,KAAK,CAACe,MAAM,KAAKrD,YAAY,CAAC4D,IAAI,EAAE;QAC7CL,OAAO,CAACP,KAAK,EAAE;QACfO,OAAO,CAAChC,MAAM,IAAI,CAAC;QACnBkC,OAAO,CAACT,KAAK,EAAE;QACfS,OAAO,CAAClC,MAAM,IAAI,CAAC;MACrB;IACF,CAAC,CAAC;IAEF,OAAOf,SAAS,CAACY,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACC,MAAM,GAAGF,CAAC,CAACE,MAAM,IAAID,CAAC,CAACwB,IAAI,GAAGzB,CAAC,CAACyB,IAAI,CAAC;EACzE;;EAEA;AACF;AACA;EACE,OAAOnC,aAAaA,CAACH,SAAS,EAAE;IAC9B,MAAMqD,MAAM,GAAG,CAAC,CAAC;IACjBrD,SAAS,CAAC6B,OAAO,CAACX,MAAM,IAAI;MAC1B,IAAI,CAACmC,MAAM,CAACnC,MAAM,CAACH,MAAM,CAAC,EAAE;QAC1BsC,MAAM,CAACnC,MAAM,CAACH,MAAM,CAAC,GAAG,EAAE;MAC5B;MACAsC,MAAM,CAACnC,MAAM,CAACH,MAAM,CAAC,CAACU,IAAI,CAACP,MAAM,CAAC;IACpC,CAAC,CAAC;IACF,OAAOmC,MAAM;EACf;;EAEA;AACF;AACA;EACE,OAAO7B,oBAAoBA,CAACN,MAAM,EAAEhB,WAAW,EAAEoD,aAAa,EAAEjD,aAAa,EAAET,eAAe,EAAE;IAC9F,MAAM2D,YAAY,GAAG/C,MAAM,CAACC,IAAI,CAACP,WAAW,CAAC,CAC1CQ,GAAG,CAACC,MAAM,CAAC,CACXM,MAAM,CAAC2B,CAAC,IAAIA,CAAC,GAAGU,aAAa,CAAC,CAC9B1C,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC;IAExB,KAAK,MAAME,MAAM,IAAIwC,YAAY,EAAE;MACjC,MAAMC,UAAU,GAAGtD,WAAW,CAACa,MAAM,CAAC,CAACE,MAAM,CAACwC,SAAS,IACrD,CAACpD,aAAa,CAACc,GAAG,CAACsC,SAAS,CAACrC,EAAE,CAAC,IAChC,CAAC,IAAI,CAACsC,gBAAgB,CAACxC,MAAM,EAAEuC,SAAS,EAAE7D,eAAe,CAC3D,CAAC;MAED,IAAI4D,UAAU,CAAC1D,MAAM,GAAG,CAAC,EAAE;QACzB;QACA,MAAM6D,QAAQ,GAAGH,UAAU,CAAC,CAAC,CAAC;QAC9B,MAAMI,KAAK,GAAG1D,WAAW,CAACa,MAAM,CAAC,CAAC8C,OAAO,CAACF,QAAQ,CAAC;QACnDzD,WAAW,CAACa,MAAM,CAAC,CAAC+C,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;QACpC,OAAOD,QAAQ;MACjB;IACF;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACE,OAAOD,gBAAgBA,CAACX,OAAO,EAAEE,OAAO,EAAErD,eAAe,EAAE;IACzD,OAAOA,eAAe,CAACmE,IAAI,CAACjC,KAAK,IAC9BA,KAAK,CAACC,SAAS,KAAKgB,OAAO,CAAC3B,EAAE,IAAIU,KAAK,CAACE,SAAS,KAAKiB,OAAO,CAAC7B,EAAE,IAChEU,KAAK,CAACC,SAAS,KAAKkB,OAAO,CAAC7B,EAAE,IAAIU,KAAK,CAACE,SAAS,KAAKe,OAAO,CAAC3B,EACjE,CAAC;EACH;;EAEA;AACF;AACA;EACE,OAAOQ,kBAAkBA,CAACjC,OAAO,EAAEC,eAAe,EAAEC,WAAW,EAAE;IAC/D,MAAMO,QAAQ,GAAG,EAAE;IACnB,MAAM4D,SAAS,GAAG,CAAC,GAAGrE,OAAO,CAAC;IAE9B,OAAOqE,SAAS,CAAClE,MAAM,IAAI,CAAC,EAAE;MAC5B,MAAMiD,OAAO,GAAGiB,SAAS,CAACC,KAAK,CAAC,CAAC;;MAEjC;MACA,IAAIC,iBAAiB,GAAG,CAAC,CAAC;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAAClE,MAAM,EAAEqE,CAAC,EAAE,EAAE;QACzC,IAAI,CAAC,IAAI,CAACT,gBAAgB,CAACX,OAAO,EAAEiB,SAAS,CAACG,CAAC,CAAC,EAAEvE,eAAe,CAAC,EAAE;UAClEsE,iBAAiB,GAAGC,CAAC;UACrB;QACF;MACF;;MAEA;MACA,IAAID,iBAAiB,KAAK,CAAC,CAAC,IAAIF,SAAS,CAAClE,MAAM,GAAG,CAAC,EAAE;QACpDoE,iBAAiB,GAAG,CAAC;MACvB;MAEA,IAAIA,iBAAiB,IAAI,CAAC,EAAE;QAC1B,MAAMjB,OAAO,GAAGe,SAAS,CAACF,MAAM,CAACI,iBAAiB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACzD9D,QAAQ,CAACqB,IAAI,CAAClC,WAAW,CAACwD,OAAO,CAAC3B,EAAE,EAAE6B,OAAO,CAAC7B,EAAE,EAAEvB,WAAW,CAAC,CAAC;MACjE;IACF;IAEA,OAAOO,QAAQ;EACjB;;EAEA;AACF;AACA;EACE,OAAO8B,cAAcA,CAAChB,MAAM,EAAErB,WAAW,EAAE;IACzC,OAAO;MACL,GAAGN,WAAW,CAAC2B,MAAM,CAACE,EAAE,EAAE,IAAI,EAAEvB,WAAW,CAAC;MAC5CgD,MAAM,EAAErD,YAAY,CAAC0D,WAAW;MAChCkB,KAAK,EAAE;IACT,CAAC;EACH;;EAEA;AACF;AACA;EACE,OAAOhC,aAAaA,CAACzC,OAAO,EAAEE,WAAW,EAAE;IACzC,MAAMO,QAAQ,GAAG,EAAE;IACnB,MAAM4D,SAAS,GAAG,CAAC,GAAGrE,OAAO,CAAC;IAE9B,OAAOqE,SAAS,CAAClE,MAAM,IAAI,CAAC,EAAE;MAC5B,MAAMiD,OAAO,GAAGiB,SAAS,CAAC1C,GAAG,CAAC,CAAC;MAC/B,MAAM2B,OAAO,GAAGe,SAAS,CAAC1C,GAAG,CAAC,CAAC;MAC/BlB,QAAQ,CAACqB,IAAI,CAAClC,WAAW,CAACwD,OAAO,CAAC3B,EAAE,EAAE6B,OAAO,CAAC7B,EAAE,EAAEvB,WAAW,CAAC,CAAC;IACjE;;IAEA;IACA,IAAImE,SAAS,CAAClE,MAAM,KAAK,CAAC,EAAE;MAC1BM,QAAQ,CAACqB,IAAI,CAAC,IAAI,CAACS,cAAc,CAAC8B,SAAS,CAAC,CAAC,CAAC,EAAEnE,WAAW,CAAC,CAAC;IAC/D;IAEA,OAAOO,QAAQ;EACjB;;EAEA;AACF;AACA;EACE,OAAOiE,qBAAqBA,CAACtC,SAAS,EAAEC,SAAS,EAAEpC,eAAe,EAAE;IAClE,IAAImC,SAAS,KAAKC,SAAS,EAAE;MAC3B,OAAO;QAAEsC,KAAK,EAAE,KAAK;QAAEC,MAAM,EAAE;MAA8C,CAAC;IAChF;IAEA,MAAMC,SAAS,GAAG5E,eAAe,CAACmE,IAAI,CAACjC,KAAK,IACzCA,KAAK,CAACC,SAAS,KAAKA,SAAS,IAAID,KAAK,CAACE,SAAS,KAAKA,SAAS,IAC9DF,KAAK,CAACC,SAAS,KAAKC,SAAS,IAAIF,KAAK,CAACE,SAAS,KAAKD,SACxD,CAAC;IAED,IAAIyC,SAAS,EAAE;MACb,OAAO;QAAEF,KAAK,EAAE,KAAK;QAAEC,MAAM,EAAE;MAAkD,CAAC;IACpF;IAEA,OAAO;MAAED,KAAK,EAAE;IAAK,CAAC;EACxB;;EAEA;AACF;AACA;EACE,OAAOG,aAAaA,CAACpC,OAAO,EAAEqC,UAAU,EAAEC,YAAY,EAAEC,YAAY,EAAE;IACpE,MAAMC,UAAU,GAAGxC,OAAO,CAACyC,SAAS,CAACC,CAAC,IAAIA,CAAC,CAAC3D,EAAE,KAAKsD,UAAU,CAAC;IAC9D,IAAIG,UAAU,KAAK,CAAC,CAAC,EAAE;MACrB,MAAM,IAAI9E,KAAK,CAAC,mBAAmB,CAAC;IACtC;IAEA,MAAMiF,QAAQ,GAAG3C,OAAO,CAACwC,UAAU,CAAC;;IAEpC;IACA,MAAMI,QAAQ,GAAG;MACf,GAAGD,QAAQ;MACXjD,SAAS,EAAE4C,YAAY;MACvB3C,SAAS,EAAE4C,YAAY;MACvB/B,MAAM,EAAErD,YAAY,CAACsD,OAAO;MAC5BoC,YAAY,EAAE,CAAC;MACfC,YAAY,EAAE;IAChB,CAAC;;IAED;IACA9C,OAAO,CAACwC,UAAU,CAAC,GAAGI,QAAQ;IAE9B,OAAO5C,OAAO;EAChB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}